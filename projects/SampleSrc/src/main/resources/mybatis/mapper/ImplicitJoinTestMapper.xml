<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="ImplicitJoinTestMapper">

    <!-- 케이스 1: 별칭 생략 (u.DEPT_ID = DEPT_ID 형태) -->
    <select id="selectUsersWithImplicitDeptId" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME
        FROM
            USERS u,
            DEPARTMENTS d
        WHERE
            u.DEPT_ID = DEPT_ID
    </select>

    <!-- 케이스 2: 동일 컬럼명 존재 및 별칭 생략 (USERS, EMPLOYEES 테이블 모두 DEPT_ID 컬럼을 가짐) -->
    <select id="selectUsersAndEmployeesWithSameColumn" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            e.EMP_NAME
        FROM
            USERS u,
            EMPLOYEES e
        WHERE
            u.DEPT_ID = DEPT_ID
            AND u.USER_ID = e.USER_ID
    </select>

    <!-- 케이스 3: 명시적 별칭 (기준점) -->
    <select id="selectUsersWithExplicitAlias" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME
        FROM
            USERS u,
            DEPARTMENTS d
        WHERE
            u.DEPT_ID = d.DEPT_ID
    </select>

    <!-- 케이스 4: 복합 조건 내 별칭 생략 -->
    <select id="selectUsersWithComplexImplicitJoin" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME
        FROM
            USERS u,
            DEPARTMENTS d
        WHERE
            u.DEPT_ID = DEPT_ID
            AND u.STATUS = 'ACTIVE'
            OR d.LOCATION = 'SEOUL'
    </select>

    <!-- 케이스 5: 서브쿼리 내 별칭 생략 -->
    <select id="selectUsersInSubqueryWithImplicitJoin" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME
        FROM
            USERS u
        WHERE
            u.DEPT_ID IN (
                SELECT
                    DEPT_ID
                FROM
                    DEPARTMENTS
                WHERE
                    DEPT_NAME LIKE '개발%'
            )
    </select>

    <!-- 케이스 6: 여러 테이블에 동일 컬럼명이 있고, 별칭이 생략된 컬럼이 WHERE 절에 여러 번 등장 -->
    <select id="selectMultipleImplicitJoinsWithSameColumn" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            e.EMP_NAME,
            d.DEPT_NAME
        FROM
            USERS u,
            EMPLOYEES e,
            DEPARTMENTS d
        WHERE
            u.DEPT_ID = DEPT_ID
            AND e.DEPT_ID = DEPT_ID
            AND u.USER_ID = e.USER_ID
    </select>

    <!-- 케이스 7: FROM 절에 서브쿼리가 있고, 그 안에서 별칭 생략 -->
    <select id="selectFromSubqueryWithImplicitJoin" resultType="map">
        SELECT
            a.USER_ID,
            a.USER_NAME,
            d.DEPT_NAME
        FROM
            (SELECT USER_ID, USER_NAME, DEPT_ID FROM USERS WHERE STATUS = 'ACTIVE') a,
            DEPARTMENTS d
        WHERE
            a.DEPT_ID = DEPT_ID
    </select>

    <!-- 케이스 8: 스칼라 쿼리, 인라인 뷰, 서브쿼리 포함 복잡한 쿼리 -->
    <select id="selectComplexQueryExample" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME,
            (SELECT COUNT(pm.PROJECT_ID) FROM PROJECT_MEMBERS pm WHERE pm.USER_ID = u.USER_ID) AS PROJECT_COUNT,
            iv.TOTAL_PROJECT_EMPLOYEES_IN_DEPT,
            iv.AVG_DEPT_SALARY
        FROM
            USERS u
        JOIN
            DEPARTMENTS d ON u.DEPT_ID = d.DEPT_ID
        JOIN
            PROJECT_MEMBERS p_mem ON u.USER_ID = p_mem.USER_ID
        JOIN
            PROJECTS p ON p_mem.PROJECT_ID = p.PROJECT_ID
        LEFT JOIN
            (
                SELECT
                    d.DEPT_ID,
                    COUNT(DISTINCT e.EMP_ID) AS TOTAL_PROJECT_EMPLOYEES_IN_DEPT,
                    AVG(e.SALARY) AS AVG_DEPT_SALARY
                FROM
                    EMPLOYEES e
                JOIN
                    DEPARTMENTS d ON e.DEPT_ID = d.DEPT_ID
                JOIN
                    PROJECT_MEMBERS pm ON e.USER_ID = pm.USER_ID
                GROUP BY
                    d.DEPT_ID
            ) iv ON d.DEPT_ID = iv.DEPT_ID
        WHERE
            u.STATUS = 'ACTIVE'
            AND u.USER_ID IN (SELECT USER_ID FROM EMPLOYEES WHERE HIRE_DATE > '2020-01-01')
            AND p.PROJECT_STATUS = 'IN_PROGRESS'
        ORDER BY
            u.USER_NAME
    </select>

    <!-- 케이스 9: EXISTS 및 IN 절에 4개 이상 테이블 조인 서브쿼리 포함 -->
    <select id="selectQueryWithExistsAndInSubqueries" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME
        FROM
            USERS u
        JOIN
            DEPARTMENTS d ON u.DEPT_ID = d.DEPT_ID
        WHERE
            -- EXISTS 서브쿼리: 특정 부서의 활성 프로젝트에 참여하는 직원이 존재하는지 확인
            EXISTS (
                SELECT 1
                FROM
                    EMPLOYEES e
                JOIN
                    PROJECT_MEMBERS pm ON e.USER_ID = pm.USER_ID
                JOIN
                    PROJECTS p ON pm.PROJECT_ID = p.PROJECT_ID
                JOIN
                    DEPARTMENTS sub_d ON e.DEPT_ID = sub_d.DEPT_ID -- 4번째 테이블
                WHERE
                    e.DEPT_ID = u.DEPT_ID
                    AND p.PROJECT_STATUS = 'ACTIVE'
                    AND sub_d.LOCATION = 'SEOUL'
            )
            AND
            -- IN 서브쿼리: 특정 조건을 만족하는 프로젝트에 참여하는 사용자 ID 목록에 현재 사용자가 포함되는지 확인
            u.USER_ID IN (
                SELECT
                    pm.USER_ID
                FROM
                    PROJECT_MEMBERS pm
                JOIN
                    PROJECTS p ON pm.PROJECT_ID = p.PROJECT_ID
                JOIN
                    EMPLOYEES e ON pm.USER_ID = e.USER_ID
                JOIN
                    DEPARTMENTS sub_d ON e.DEPT_ID = sub_d.DEPT_ID -- 4번째 테이블
                WHERE
                    p.START_DATE > '2023-01-01'
                    AND e.HIRE_DATE < '2024-01-01'
                    AND sub_d.DEPT_NAME LIKE '영업%'
            )
        ORDER BY
            u.USER_NAME
    </select>

    <!-- 케이스 10: EXISTS 및 IN 절에 4개 이상 테이블 조인 서브쿼리 포함 (Implicit Join 메인 쿼리) -->
    <select id="selectImplicitJoinWithComplexConditions" resultType="map">
        SELECT
            u.USER_ID,
            u.USER_NAME,
            d.DEPT_NAME
        FROM
            USERS u,
            DEPARTMENTS d
        WHERE
            u.DEPT_ID = d.DEPT_ID -- Implicit Join 조건
            AND
            -- EXISTS 서브쿼리: 특정 부서의 활성 프로젝트에 참여하는 직원이 존재하는지 확인
            EXISTS (
                SELECT 1
                FROM
                    EMPLOYEES e
                JOIN
                    PROJECT_MEMBERS pm ON e.USER_ID = pm.USER_ID
                JOIN
                    PROJECTS p ON pm.PROJECT_ID = p.PROJECT_ID
                JOIN
                    DEPARTMENTS sub_d ON e.DEPT_ID = sub_d.DEPT_ID -- 4번째 테이블
                WHERE
                    e.DEPT_ID = u.DEPT_ID
                    AND p.PROJECT_STATUS = 'ACTIVE'
                    AND sub_d.LOCATION = 'SEOUL'
            )
            AND
            -- IN 서브쿼리: 특정 조건을 만족하는 프로젝트에 참여하는 사용자 ID 목록에 현재 사용자가 포함되는지 확인
            u.USER_ID IN (
                SELECT
                    pm.USER_ID
                FROM
                    PROJECT_MEMBERS pm
                JOIN
                    PROJECTS p ON pm.PROJECT_ID = p.PROJECT_ID
                JOIN
                    EMPLOYEES e ON pm.USER_ID = e.USER_ID
                JOIN
                    DEPARTMENTS sub_d ON e.DEPT_ID = sub_d.DEPT_ID -- 4번째 테이블
                WHERE
                    p.START_DATE > '2023-01-01'
                    AND e.HIRE_DATE < '2024-01-01'
                    AND sub_d.DEPT_NAME LIKE '영업%'
            )
        ORDER BY
            u.USER_NAME
    </select>

</mapper>
