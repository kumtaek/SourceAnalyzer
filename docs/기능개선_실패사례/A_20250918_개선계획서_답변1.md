# 개선계획서_Gemini.md 개발 구현 관련 답변서

## 문서 정보
- **작성일**: 2025년 9월 18일
- **답변자**: Gemini (AI Assistant)
- **대상 문서**: `docs/기능개선/Q_20250918_개선계획서_질의1.md`
- **답변 목적**: 제기된 기술적 질의에 대한 구체적인 해결 방안과 보완된 개발 전략 제시

---

## 🎯 핵심 질의사항 답변

### 1. **MyBatis 동적 SQL 분석 - 성능 및 복잡도 관련**

#### 1-1. 조합 폭발 문제

**정확한 지적입니다.** `<if>` 태그가 많아질 경우 발생하는 조합 폭발(Combinatorial Explosion)은 반드시 해결해야 할 문제입니다. 제안서의 내용은 개념을 설명하기 위한 것이었으며, 실제 구현 시에는 다음과 같은 안전장치를 포함해야 합니다.

-   **메모리 및 처리 시간**:
    1.  **최대 조합 수 제한 (Safety Guard)**: 모든 조합을 생성하는 대신, 최대 조합 수를 **32개 (2^5)** 또는 **64개 (2^6)** 정도로 제한하는 '안전장치'를 도입하겠습니다. 이는 약 5~6개의 독립적인 `<if>` 태그에 해당하는 수치로, 대부분의 실용적인 케이스를 커버하면서도 성능 저하를 막을 수 있습니다.
    2.  **대표 경로 분석 (Graceful Degradation)**: 최대 조합 수를 초과하는 복잡한 쿼리의 경우, 모든 조합을 생성하는 것을 포기하고, 대신 **2개의 대표 경로**만 분석합니다.
        *   **최대 경로 (Inclusive Path)**: 모든 `<if>` 조건을 `true`로 간주하여 만들 수 있는 가장 복잡한 형태의 SQL 1개.
        *   **최소 경로 (Base Path)**: 모든 `<if>` 조건을 `false`로 간주하여 만들 수 있는 가장 기본적인 형태의 SQL 1개.
        *   이 방식을 통해, 성능 저하 없이 최소한의 필수 테이블/컬럼 정보는 반드시 수집할 수 있습니다.

-   **결론**: 무한정 조합을 생성하는 대신, **제한된 수의 조합 + 대표 경로 분석** 전략을 통해 현실적인 시간과 메모리 내에서 분석을 완료하도록 설계하겠습니다.

#### 1-2. 중첩 구조 처리

**이 또한 매우 중요한 문제입니다.** 제안서의 재귀 방식은 `<choose>`의 상호배타적 특성을 고려하지 않은 단순화된 모델이었습니다. 이를 다음과 같이 구체화하겠습니다.

-   **논리 조합 처리**: **상태를 가진 재귀(Stateful Recursion)** 방식을 사용하겠습니다.
    *   **`<if>` 노드**: 현재까지의 모든 SQL 경로들을 복제하여, '`<if>` 내부를 포함하는 경로'와 '포함하지 않는 경로' 두 그룹으로 분기시킵니다.
    *   **`<choose>` 노드**: 하위의 `<when>`과 `<otherwise>`는 상호배타적이므로, 현재 경로를 각 `when/otherwise`의 수만큼 복제하여 각각의 내부 로직을 적용합니다. 즉, `choose`를 만나면 경로는 하나로 합쳐지는 것이 아니라, 가능한 선택지만큼 갈라집니다.
-   **재귀 깊이 및 에러 처리**:
    *   **최대 재귀 깊이(Max Depth)**를 **15단계**로 명시적으로 제한하여 무한 재귀 및 스택 오버플로우를 방지합니다.
    *   최대 깊이를 초과하면, 해당 분기 탐색을 중단하고 경고 로그를 남긴 후, 현재까지 분석된 내용만 반환하여 전체 프로세스가 중단되지 않도록 합니다.

### 2. **MyBatis `<include>` 태그 - 의존성 추적 관련**

#### 2-1. 순환 참조 문제

-   **순환 참조 탐지**: **DFS(깊이 우선 탐색)** 알고리즘을 사용하며, 현재 탐색 중인 `<include>`의 `refid`를 **호출 스택(Call Stack)처럼 Set에 기록**하면서 진행합니다. 재귀 호출 시 `refid`가 이미 스택 Set에 존재한다면 순환 참조로 간주합니다.
-   **에러 처리**: 순환 참조가 발견되면, 해당 `<include>` 태그의 확장을 중단하고 **경고 로그를 기록한 뒤 빈 문자열을 반환**합니다. 전체 분석을 중단시키지 않고, 문제가 되는 부분만 스킵하여 최대한 많은 정보를 수집하는 것을 목표로 합니다.
-   **성능**: 의존성 그래프는 분석 시작 시 **최초 1회만 빌드**하여 `SqlFragmentCache`에 저장합니다. 이후 분석에서는 이 캐시를 사용하므로, 대규모 프로젝트에서도 전체 분석 시간에 미치는 영향은 미미할 것입니다.

#### 2-2. 네임스페이스 충돌

-   **ID 충돌 해결**: `SqlFragmentCache`의 키 생성 전략을 **`네임스페이스 + "." + id`** 형태로 고도화하여 ID의 고유성을 보장하겠습니다.
-   **참조 해석 규칙**: `<include refid="...">`를 해석할 때, 다음과 같은 우선순위로 `refid`를 찾습니다.
    1.  **`네임스페이스.id` 형태의 완전한 refid**가 있는지 우선 확인.
    2.  없다면, **현재 XML 파일의 `namespace`** + `.` + `refid`로 조합하여 조회.
    3.  그래도 없다면, `refid` 자체만으로 조회 (다른 파일에 동일 id가 있을 경우 충돌 가능성 경고 로깅).
-   이러한 계층적 조회 방식을 통해 대부분의 `refid`를 명확하게 해석할 수 있습니다.

### 3. **Java AST 분석 - 라이브러리 및 정확도 관련**

#### 3-1. javalang 라이브러리 한계

-   **라이브러리 선택**: `javalang`은 순수 Python으로 작성되어 설치가 간편하고 기본적인 AST 구조를 얻기에 충분하여 **MVP(최소 기능 구현) 단계에서는 최적의 선택**입니다. `tree-sitter`는 더 강력하지만 C 컴파일러 의존성 등 외부 종속성이 복잡하여 초기 도입에는 허들이 있습니다.
-   **정확도 및 추적 범위**: **'최소 노력으로 최대 효과(Low-hanging fruit)'** 전략을 채택하겠습니다.
    *   **1단계 목표 (In-Scope)**: 메서드 내에서 **`String` 타입의 지역 변수**가 **문자열 리터럴(Literal)**과 `+` 또는 `+=` 연산자로 결합되는 **단순하고 선형적인 패턴**만 추적합니다.
    *   **분석 포기 대상 (Out-of-Scope)**: **메서드 호출 결과**, **삼항 연산자**, `replace()`와 같은 문자열 메서드, 다른 클래스나 필드 변수 참조 등은 정적 분석의 복잡도가 기하급수적으로 증가하므로 **초기 버전에서는 명시적으로 포기**합니다.
-   **성능**: `javalang`은 대용량 파일 파싱 시 성능 저하가 발생할 수 있습니다. 따라서 파일 크기가 **5MB 이상인 경우, Java 동적 SQL 분석을 건너뛰는** 예외 처리를 추가하겠습니다.

#### 3-2. 스코프 및 타입 추론

-   **변수 스코프**: 분석 범위를 **메서드 내 지역 변수(Local Variable Scope)**로 명확히 한정합니다. 메서드의 파라미터로 전달되거나, 다른 메서드의 반환 값으로 사용되는 순간 해당 변수에 대한 추적은 중단합니다.
-   **타입 추론**: 초기 버전에서는 **`String` 타입만 지원**합니다. `StringBuilder`, `StringBuffer`는 더 복잡한 API 호출 패턴을 분석해야 하므로 추후 확장 과제로 남겨둡니다.
-   **한계 설정**: 위에서 언급한 '분석 포기 대상' 규칙에 따라, 복잡한 패턴을 만나면 즉시 추적을 포기하고 현재까지 수집된 정보만 활용합니다. 이는 **완벽함보다 실용성을 추구**하는 전략입니다.

### 4. **통합 아키텍처 - 기존 시스템과의 연동**

#### 4-1. 기존 파서와의 충돌

-   **호환성**: 기존 `MybatisParser` 클래스를 **교체(Replace)가 아닌 확장(Extend)**하는 방식으로 구현하겠습니다. 새로운 동적 분석 로직을 별도의 메서드로 구현하고, 기존 `parse_sql_node` 메서드 시작 부분에서 이 로직을 호출하는 형태로 연동하여 기존 코드에 미치는 영향을 최소화합니다.
-   **설정 연동**: 새로운 기능은 기존 `*.yaml` 설정에 영향을 받지 않는 독립적인 모듈로 작동합니다.
-   **에러 처리**: 새로운 동적 분석 로C직(AST, 동적 SQL 조합)에서 에러 발생 시, 해당 에러를 로깅하고 **기존의 정적 분석 방식(SAX Fallback 등)으로 자연스럽게 넘어가도록(Fallback)** 구현하여 안정성을 확보합니다.

#### 4-2. 성능 영향 평가

-   **처리 시간**: `sampleSrc` 기준, 캐싱이 없는 최초 실행 시 전체 분석 시간은 약 **1.5배 ~ 2배 증가**할 것으로 예상합니다. 하지만 `SqlFragmentCache`와 같은 캐싱 전략 덕분에 **반복 실행 시에는 성능 저하가 거의 없을 것**입니다.
-   **메모리 사용량**: `SqlFragmentCache`가 가장 큰 메모리 증가 요인이지만, 텍스트 기반이므로 수백 개의 XML 파일이라도 수십 MB 수준일 것으로 예상됩니다. 동적 SQL 조합은 최대 개수 제한으로 메모리 사용량을 통제합니다.
-   **확장성**: '조합 폭발 방지', '순환 참조 방지' 등의 안전장치가 핵심입니다. 이 장치들이 잘 작동한다면, 프로젝트 크기가 10배가 되더라도 분석 시간은 선형적으로 증가하여 실용적인 수준을 유지할 수 있습니다.

### 5. **구현 우선순위 및 단계별 검증**

#### 5-1. 최소 기능 구현(MVP) 범위

제안하신 단계별 접근에 동의하며, Phase 1의 MVP 범위를 다음과 같이 명확히 정의합니다.

-   **`<if>` 태그**: **중첩 구조가 없는 단일 `<if>` 태그**만 지원 (true/false 2개 경로 생성).
-   **`<include>` 태그**: **동일한 XML 파일 내에서의 참조**만 지원.
-   **Java `+` 연산자**: **2~3개의 문자열 리터럴**이 결합되는 단순한 선형 패턴만 지원.

#### 5-2. 검증 방법

-   **정확성 측정**: 개선 전/후 **'추출된 테이블 수', '추출된 조인 관계 수', '추출된 SQL 컴포넌트 수'**를 `sampleSrc` 프로젝트 기준으로 정량적으로 비교 측정하고, 수동 분석 결과와 비교하여 정확도를 평가합니다.
-   **테스트 케이스**: `test_cases/` 디렉토리를 신설하고, 각 기능(중첩 if, 순환 include, 복잡한 Java `+` 연산 등)을 테스트할 수 있는 **작은 단위의 XML 및 Java 파일을 생성하여 단위 테스트를 구성**하겠습니다.
-   **성능 벤치마크**: `sampleSrc` 분석 시간을 기준으로, 개선 후 분석 시간이 **기존 대비 2.5배를 초과하지 않는 것**을 성능 저하 허용 범위로 설정하겠습니다.

---

## 🔧 기술적 제안사항 반영

제안해주신 **점진적 구현, 성능 최적화, 에러 처리 전략**은 모두 본 답변에 적극적으로 반영하였습니다. 특히 **Graceful Degradation**과 **상세 로깅**은 복잡한 기능을 안정적으로 시스템에 통합하는 데 핵심적인 역할을 할 것입니다.

---

**답변 요약**: 제기해주신 모든 우려 사항은 타당하며, 이를 해결하기 위해 **안전장치(최대 조합 수, 최대 깊이), 명확한 분석 범위 설정(단순 패턴 우선), 단계적 구현(MVP), 그리고 견고한 에러 처리(Fallback)**를 포함한 고도화된 개발 전략을 수립하여 진행하겠습니다.
