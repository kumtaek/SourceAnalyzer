# 개발자 구현 가이드

## 문서 정보
- **작성일**: 2025-01-17
- **버전**: v1.0
- **목적**: 개발자가 즉시 구현에 착수할 수 있도록 구체적인 구현 방법 제공
- **대상 독자**: 개발자, 구현 담당자

## 1. 개발 환경 설정

### 1.1 필수 요구사항
```bash
Python 3.10+
SQLite (소스분석기 메타데이터 저장용)
Git
```

**중요**: 
- **소스분석기**: SQLite 사용 (메타데이터 저장용)
- **분석 대상 소스코드**: Oracle 사용 (분석 대상)

즉, 우리가 개발하는 도구는 SQLite로 메타데이터를 저장하고, 분석하는 대상 소스코드에서 Oracle 쿼리를 추출하여 분석합니다.

### 1.2 개발 환경 구성
```bash
# 가상환경 생성
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# 필수 패키지 설치
pip install -r requirements.txt
```

### 1.3 requirements.txt
```
# 데이터베이스 (SQLite - 소스분석기 메타데이터 저장용)
sqlalchemy==2.0.23

# 파일 처리
chardet==5.2.0
python-magic==0.4.27

# XML/HTML 파싱
lxml==4.9.3
beautifulsoup4==4.12.2

# 설정 파일
PyYAML==6.0.1
configparser==6.0.0

# 로깅
loguru==0.7.2

# 테스트
pytest==7.4.3
pytest-cov==4.1.0

# 유틸리티
click==8.1.7
tqdm==4.66.1
```

## 2. 핵심 인터페이스 정의

### 2.1 BaseAnalyzer 인터페이스
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

@dataclass
class AnalysisResult:
    """분석 결과 표준 형식"""
    components: List[Dict[str, Any]]
    relationships: List[Dict[str, Any]]
    inferred_objects: List[Dict[str, Any]]
    metadata: Dict[str, Any]
    success: bool
    error_message: Optional[str] = None

class BaseAnalyzer(ABC):
    """기본 분석기 인터페이스"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = get_logger(self.__class__.__name__)
    
    @abstractmethod
    def analyze(self, file_path: str, file_content: str) -> AnalysisResult:
        """파일 분석 메인 메서드"""
        pass
    
    @abstractmethod
    def get_supported_extensions(self) -> List[str]:
        """지원하는 파일 확장자 목록"""
        pass
    
    @abstractmethod
    def get_analyzer_name(self) -> str:
        """분석기 이름"""
        pass
    
    def validate_file(self, file_path: str, file_content: str) -> bool:
        """파일 유효성 검증"""
        return True
    
    def extract_basic_info(self, file_path: str, file_content: str) -> Dict[str, Any]:
        """기본 정보 추출 (Fallback용)"""
        return {
            "file_path": file_path,
            "file_size": len(file_content),
            "line_count": len(file_content.splitlines())
        }
```

### 2.2 RelationshipEngine 인터페이스
```python
from dataclasses import dataclass
from typing import List, Dict, Any

@dataclass
class Component:
    """컴포넌트 정보"""
    component_id: str
    component_name: str
    component_type: str
    source_file: str
    is_inferred: bool = False
    metadata: Dict[str, Any] = None

@dataclass
class Relationship:
    """관계 정보"""
    src_id: str
    dst_id: str
    rel_type: str
    source_file: str
    confidence: float = 1.0
    is_inferred: bool = False
    metadata: Dict[str, Any] = None

class RelationshipEngine:
    """연관관계 도출 엔진"""
    
    def __init__(self, project_id: str, db_connection):
        self.project_id = project_id
        self.db_connection = db_connection
        self.logger = get_logger(__name__)
    
    def extract_immediate_relationships(self, 
                                      file_content: str, 
                                      file_path: str,
                                      file_type: str) -> List[Relationship]:
        """파일 분석과 동시에 즉시 관계 추출"""
        pass
    
    def store_relationships_immediately(self, relationships: List[Relationship]):
        """관계를 즉시 DB에 저장"""
        pass
    
    def store_components_immediately(self, components: List[Component]):
        """컴포넌트를 즉시 DB에 저장"""
        pass
    
    def check_inferred_evolution(self, content: str, file_path: str):
        """INFERRED 객체 진화 체크"""
        pass
```

## 3. 설정 파일 구조 정의

### 3.1 SQL 패턴 설정 (config/patterns/sql_patterns.yaml)
```yaml
sql_analysis:
  table_extraction_patterns:
    - name: "standard_from_join"
      pattern: "(?:FROM|JOIN)\\s+(\\w+)(?:_\\$\\{[^}]+\\})?\\s+(\\w+)"
      confidence: 0.95
      description: "표준 FROM/JOIN 구문"
    
    - name: "oracle_implicit_join"
      pattern: "FROM\\s+((?:\\w+(?:_\\$\\{[^}]+\\})?\\s+\\w+,?\\s*)+)"
      confidence: 0.80
      description: "Oracle 암시적 조인"
    
    - name: "subquery_table"
      pattern: "(?:IN|EXISTS)\\s*\\(\\s*SELECT[^)]+FROM\\s+(\\w+)"
      confidence: 0.85
      description: "서브쿼리 내 테이블"
    
    - name: "java_string_sql"
      pattern: "\"[^\"]*FROM\\s+(\\w+)[^\"]*\""
      confidence: 0.70
      description: "Java 문자열 내 SQL"

  join_condition_patterns:
    - name: "explicit_join_on"
      pattern: "ON\\s+(\\w+)\\.(\\w+)\\s*=\\s*(\\w+)\\.(\\w+)"
      confidence: 0.95
      description: "명시적 JOIN ON 조건"
    
    - name: "implicit_join_where"
      pattern: "WHERE.*?(\\w+)\\.(\\w+)\\s*=\\s*(\\w+)\\.(\\w+)"
      confidence: 0.90
      description: "암시적 JOIN WHERE 조건"
    
    - name: "oracle_outer_join"
      pattern: "(\\w+)\\.(\\w+)\\s*\\(\\+\\)\\s*=\\s*(\\w+)\\.(\\w+)"
      confidence: 0.85
      description: "Oracle 외부 조인"

  query_type_patterns:
    - name: "select_query"
      pattern: "^\\s*SELECT\\s+"
      query_type: "SELECT"
      confidence: 1.0
    
    - name: "insert_query"
      pattern: "^\\s*INSERT\\s+INTO\\s+"
      query_type: "INSERT"
      confidence: 1.0
    
    - name: "update_query"
      pattern: "^\\s*UPDATE\\s+"
      query_type: "UPDATE"
      confidence: 1.0
    
    - name: "delete_query"
      pattern: "^\\s*DELETE\\s+FROM\\s+"
      query_type: "DELETE"
      confidence: 1.0
```

### 3.2 Java 패턴 설정 (config/patterns/java_patterns.yaml)
```yaml
java_analysis:
  class_extraction_patterns:
    - name: "public_class"
      pattern: "public\\s+class\\s+(\\w+)\\s*(?:extends\\s+\\w+)?\\s*(?:implements\\s+[^{]+)?\\s*\\{"
      confidence: 0.95
    
    - name: "interface_declaration"
      pattern: "public\\s+interface\\s+(\\w+)\\s*(?:extends\\s+[^{]+)?\\s*\\{"
      confidence: 0.95
    
    - name: "annotation_class"
      pattern: "@\\w+\\s*public\\s+class\\s+(\\w+)"
      confidence: 0.90

  method_extraction_patterns:
    - name: "public_method"
      pattern: "public\\s+(?:static\\s+)?(?:\\w+\\s+)?(\\w+)\\s*\\([^)]*\\)\\s*(?:throws\\s+[^{]+)?\\s*\\{"
      confidence: 0.90
    
    - name: "annotation_method"
      pattern: "@\\w+(?:\\([^)]*\\))?\\s*public\\s+(?:\\w+\\s+)?(\\w+)\\s*\\([^)]*\\)"
      confidence: 0.85

  sql_extraction_patterns:
    - name: "jdbc_statement"
      pattern: "(?:stmt|statement)\\.(?:executeQuery|executeUpdate)\\s*\\(\\s*[\"']([^\"']+)[\"']"
      confidence: 0.90
    
    - name: "jpa_query_method"
      pattern: "(\\w+)(?:By|And|Or)(\\w+)(?:\\([^)]*\\))?"
      confidence: 0.85
    
    - name: "mybatis_mapper_call"
      pattern: "(\\w+)\\.(\\w+)\\s*\\([^)]*\\)"
      confidence: 0.80
```

## 4. 데이터베이스 연동 구현

### 4.1 DatabaseUtils 구현
```python
from sqlalchemy import create_engine, text
from contextlib import contextmanager
from util.logger import get_logger

class DatabaseUtils:
    """데이터베이스 유틸리티 (SQLite 사용)"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.engine = None
        self.logger = get_logger(__name__)
    
    def connect(self):
        """SQLite 데이터베이스 연결"""
        try:
            db_path = self.config.get('sqlite_db_path', 'metadata.db')
            connection_string = f"sqlite:///{db_path}"
            self.engine = create_engine(connection_string, echo=False)
            self.logger.info(f"SQLite 데이터베이스 연결 성공: {db_path}")
        except Exception as e:
            handle_error(f"SQLite 데이터베이스 연결 실패: {str(e)}", e)
    
    @contextmanager
    def get_connection(self):
        """컨텍스트 매니저로 연결 관리"""
        if not self.engine:
            self.connect()
        
        connection = None
        try:
            connection = self.engine.connect()
            yield connection
        except Exception as e:
            if connection:
                connection.rollback()
            raise e
        finally:
            if connection:
                connection.close()
    
    def execute_query(self, query: str, params: List[Any] = None) -> List[Dict]:
        """쿼리 실행"""
        with self.get_connection() as conn:
            result = conn.execute(text(query), params or [])
            return [dict(row._mapping) for row in result]
    
    def execute_insert(self, query: str, params: List[Any] = None) -> int:
        """INSERT 실행"""
        with self.get_connection() as conn:
            result = conn.execute(text(query), params or [])
            conn.commit()
            return result.rowcount
    
    def execute_batch_insert(self, query: str, params_list: List[List[Any]]) -> int:
        """배치 INSERT 실행"""
        with self.get_connection() as conn:
            result = conn.execute(text(query), params_list)
            conn.commit()
            return result.rowcount
```

## 5. 오류 처리 구현

### 5.1 handle_error 함수 구현
```python
import sys
from util.logger import get_logger

def handle_error(message: str, exception: Exception = None, exit_code: int = 1):
    """오류 처리 및 프로그램 종료"""
    logger = get_logger(__name__)
    
    # 로그에 오류 기록
    if exception:
        logger.error(f"{message}: {str(exception)}", exc_info=True)
    else:
        logger.error(message)
    
    # 콘솔에 오류 메시지 출력
    print(f"오류: {message}")
    if exception:
        print(f"상세: {str(exception)}")
    
    # 프로그램 종료
    sys.exit(exit_code)
```

## 6. 테스트 전략

### 6.1 테스트 구조
```
tests/
├── __init__.py
├── conftest.py              # pytest 설정
├── test_engine/             # 엔진 테스트
│   ├── test_relationship_engine.py
│   ├── test_sql_analyzer.py
│   └── test_pattern_matcher.py
├── test_analyzers/          # 분석기 테스트
│   ├── test_xml_analyzer.py
│   ├── test_java_analyzer.py
│   └── test_frontend_analyzer.py
├── test_pipeline/           # 파이프라인 테스트
│   ├── test_main_pipeline.py
│   └── test_processors.py
├── test_utils/              # 유틸리티 테스트
│   ├── test_database_utils.py
│   └── test_file_utils.py
└── fixtures/                # 테스트 데이터
    ├── sample_files/
    └── test_configs/
```

### 6.2 테스트 실행 방법
```bash
# 전체 테스트 실행
pytest

# 특정 모듈 테스트
pytest tests/test_engine/

# 커버리지 포함 테스트
pytest --cov=src --cov-report=html

# 성능 테스트
pytest tests/test_performance.py -v
```

## 7. 개발 우선순위

### 7.1 1단계: 기본 인프라 (1주)
1. 프로젝트 구조 생성
2. `util/` 모듈 구현 (database_utils, logger, file_utils)
3. 기본 설정 파일 구현
4. 테스트 환경 구성

### 7.2 2단계: 핵심 엔진 (2주)
1. `engine/relationship_engine.py` 구현
2. `engine/sql_analyzer.py` 구현
3. `engine/pattern_matcher.py` 구현
4. 기본 테스트 작성

### 7.3 3단계: 분석기 구현 (3주)
1. `analyzers/xml_analyzer.py` 구현
2. `analyzers/java_analyzer.py` 구현
3. `analyzers/frontend_analyzer.py` 구현
4. `analyzers/fallback_analyzer.py` 구현

### 7.4 4단계: 파이프라인 통합 (2주)
1. `pipeline/main_pipeline.py` 구현
2. 각 단계별 processor 구현
3. 통합 테스트 작성
4. 성능 최적화

### 7.5 5단계: 테스트 및 검증 (1주)
1. 전체 시스템 테스트
2. SampleSrc 프로젝트로 검증
3. 성능 측정 및 최적화
4. 문서화 완성

## 8. 개발 시 주의사항

### 8.1 코딩 규칙
- 모든 함수는 타입 힌트 포함
- docstring 필수 (Google 스타일)
- 예외 발생 시 반드시 `handle_error()` 호출
- 하드코딩 금지, 설정 파일 활용

### 8.2 성능 고려사항
- 대용량 파일 처리 시 스트리밍 방식 사용
- 데이터베이스 연결 풀 활용
- 메모리 사용량 모니터링
- 배치 처리로 DB 부하 최소화

### 8.3 확장성 고려사항
- 새로운 파일 타입 추가 시 플러그인 방식 활용
- 패턴 추가 시 설정 파일만 수정
- 인터페이스 변경 시 하위 호환성 유지
