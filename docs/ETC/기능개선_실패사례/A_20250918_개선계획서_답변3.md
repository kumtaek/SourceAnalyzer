# 최종 개선계획서: User Rules 준수 구현 가이드 (v3)

## 문서 정보
- **작성일**: 2025년 9월 18일
- **답변자**: Gemini (AI Assistant)
- **대상 문서**: `docs/기능개선/Q_20250918_개선계획서_질의3.md`
- **답변 목적**: 모든 User Rules를 준수하는, 코드 레벨의 최종 구현 명세를 제공하여 즉시 개발 착수 지원

---

## 1. 최종 아키텍처: 안전한 확장 및 통합 방안

**핵심 전략**: 기존 `MybatisParser`를 직접 수정하지 않고, 새로운 `EnhancedMybatisParser`를 만들어 기능을 확장하고, `XmlParser`에서 제어하는 방식으로 안정성을 확보합니다.

```python
# D:\Analyzer\CreateMetaDb\parser\xml_parser.py (구조 예시)

class XmlParser:
    def __init__(self, ...):
        # ...
        # EnhancedMybatisParser 인스턴스 생성
        self.enhanced_parser = EnhancedMybatisParser(...)

    def _parse_with_dom(self, xml_file: str):
        try:
            # 1. 새로운 강화된 파서 먼저 시도
            result = self.enhanced_parser.parse_sql_mapper(xml_root)
            info(f"[신규 파서 성공] 동적 분석 완료: {xml_file}")
            return result
        except Exception as e:
            # 2. 실패 시, 경고 로그 남기고 기존 파서로 Fallback
            warning(f"[Fallback] 신규 파서 실패, 기존 방식으로 전환: {xml_file}, 사유: {e}")
            # 기존 MybatisParser 로직 호출
            legacy_parser = MybatisParser(...) 
            return legacy_parser.parse_sql_mapper(xml_root)

# 새로운 EnhancedMybatisParser 클래스 (기존 MybatisParser와 분리)
class EnhancedMybatisParser:
    # 여기에 모든 신규 로직(include, dynamic SQL) 구현
    pass

# 기존 MybatisParser 클래스 (수정 없음)
class MybatisParser:
    # ... 기존 로직 그대로 ...
```

**답변 C (안전한 추가 방법)**: 이 구조는 신규 기능 추가로 인해 기존 시스템에 장애가 전파될 가능성을 원천적으로 차단합니다. 신규 로직은 `EnhancedMybatisParser` 내에 완전히 격리됩니다.

---

## 2. Phase 1-A 상세 구현 계획 (1주차)

### **2.1. `SqlFragmentCache` 구현 (`util/cache_utils.py`)**

**User Rules 반영**:
- 기존 `AnalysisCache`와 역할이 다르므로 **신규 클래스로 생성**하여 중복 및 혼선을 방지합니다.
- 파일 경로는 `PathUtils`를 사용하고, 분석 대상은 `target_source_config.yaml`을 따릅니다.

```python
# D:\Analyzer\CreateMetaDb\util\cache_utils.py 에 추가

import xml.etree.ElementTree as ET
from typing import Dict, Optional
from .path_utils import PathUtils
from .logger import info, warning, handle_error

class SqlFragmentCache:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(SqlFragmentCache, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.fragments: Dict[str, ET.Element] = {}
            self.initialized: bool = False
            self.path_utils = PathUtils()

    def load_all_fragments(self, project_name: str, target_config: dict):
        if self.initialized:
            return
        
        project_path = self.path_utils.get_project_source_path(project_name)
        
        # target_source_config.yaml 기반으로 파일 검색
        include_patterns = target_config.get('file_type_settings', {}).get('xml', {}).get('include_patterns', ["**/*.xml"])
        exclude_patterns = target_config.get('file_type_settings', {}).get('xml', {}).get('exclude_patterns', [])
        
        try:
            # PathUtils를 사용하여 파일 목록 가져오기
            xml_files = self.path_utils.find_files_by_patterns(project_path, include_patterns, exclude_patterns)
            info(f"SQL 조각 캐싱을 위해 {len(xml_files)}개의 XML 파일을 스캔합니다.")

            for file_path in xml_files:
                try:
                    tree = ET.parse(file_path)
                    root = tree.getroot()
                    namespace = root.attrib.get('namespace', '')
                    for sql_node in root.findall('sql'):
                        node_id = sql_node.attrib.get('id')
                        if node_id:
                            # 네임스페이스 포함 키와 미포함 키 모두 저장
                            if namespace:
                                self.fragments[f"{namespace}.{node_id}"] = sql_node
                            self.fragments[node_id] = sql_node
                except ET.ParseError as e:
                    warning(f"XML 파싱 오류로 SQL 조각 캐시를 건너뜁니다: {file_path}, 사유: {e}")
                    continue # 파싱 오류는 전체를 중단시키지 않음
        except Exception as e:
            handle_error(e, "SqlFragmentCache 로딩 중 심각한 오류 발생")

        self.initialized = True
        info(f"SqlFragmentCache 초기화 완료. 총 {len(self.fragments)}개의 SQL 조각 로드됨.")

    def get_fragment_node(self, refid: str, current_namespace: str = '') -> Optional[ET.Element]:
        # 1. 네임스페이스.refid 형태로 먼저 조회
        if current_namespace and f"{current_namespace}.{refid}" in self.fragments:
            return self.fragments[f"{current_namespace}.{refid}"]
        # 2. refid 자체로 조회
        if refid in self.fragments:
            return self.fragments[refid]
        return None

# 전역 인스턴스 관리 함수
_sql_fragment_cache_instance = None
def get_sql_fragment_cache() -> SqlFragmentCache:
    global _sql_fragment_cache_instance
    if _sql_fragment_cache_instance is None:
        _sql_fragment_cache_instance = SqlFragmentCache()
    return _sql_fragment_cache_instance
```

### **2.2. `EnhancedMybatisParser` 구현 (`parser/xml_parser.py`)**

**User Rules 반영**:
- **목표 집중**: 테이블/조인 관계 추출에 집중. 복잡한 SQL 조합 대신, 모든 텍스트를 합친 후 정규식으로 테이블을 추출하는 **단순화된 접근법 채택**. (질의 4-1-1 반영)
- **안전성**: 순환 참조 탐지 로직 포함. 최대 재귀 깊이 제한.

```python
# D:\Analyzer\CreateMetaDb\parser\xml_parser.py 에 추가

from util.cache_utils import get_sql_fragment_cache

MAX_INCLUDE_DEPTH = 10

class EnhancedMybatisParser:
    def __init__(self):
        self.fragment_cache = get_sql_fragment_cache()
        # SQL에서 테이블, 조인 등을 추출하는 SqlJoinAnalyzer 재사용
        self.sql_join_analyzer = SqlJoinAnalyzer() 

    def parse_sql_mapper(self, xml_root: ET.Element) -> List[Dict[str, Any]]:
        reconstructed_sqls = []
        namespace = xml_root.attrib.get('namespace', '')
        sql_tags = ['select', 'insert', 'update', 'delete', 'merge']

        for tag_name in sql_tags:
            for statement_node in xml_root.findall(tag_name):
                sql_id = statement_node.get('id')
                if not sql_id:
                    continue
                
                try:
                    # 1. <include> 해석하여 모든 텍스트 재귀적으로 추출
                    # 순환참조 방지를 위해 호출 스택(Set) 전달
                    full_sql_text = self._get_text_with_includes(statement_node, namespace, set())
                    
                    if full_sql_text.strip():
                        # 2. SqlJoinAnalyzer를 사용해 테이블 및 조인 관계 분석
                        # component_id는 상위 XmlParser에서 최종적으로 매핑
                        analysis_result = self.sql_join_analyzer.analyze(full_sql_text)
                        
                        reconstructed_sqls.append({
                            'sql_id': sql_id,
                            'tag_name': tag_name,
                            'sql_content': full_sql_text,
                            'analysis_result': analysis_result # 테이블, 조인 정보 포함
                        })
                except RecursionError as e:
                    warning(f"<include> 순환 참조 또는 최대 깊이 초과: {namespace}.{sql_id}, 사유: {e}")
                    # 순환 참조 발생 시 해당 SQL은 건너뛰고 계속 진행
                    continue
        return reconstructed_sqls

    def _get_text_with_includes(self, node: ET.Element, namespace: str, call_stack: set, depth: int = 0) -> str:
        if depth > MAX_INCLUDE_DEPTH:
            raise RecursionError("최대 <include> 재귀 깊이 초과")

        # 텍스트, 자식, 꼬리 순서로 모든 텍스트를 조합
        parts = [node.text] if node.text else []
        for child in node:
            if child.tag == 'include':
                refid = child.attrib.get('refid')
                if not refid:
                    continue
                
                # 순환 참조 확인
                if refid in call_stack:
                    raise RecursionError(f"순환 참조 발견: {refid}")
                
                fragment_node = self.fragment_cache.get_fragment_node(refid, namespace)
                if fragment_node is not None:
                    call_stack.add(refid)
                    parts.append(self._get_text_with_includes(fragment_node, namespace, call_stack, depth + 1))
                    call_stack.remove(refid) # 현재 경로 탐색 후 스택에서 제거
            else:
                # 다른 모든 태그(<if>, <choose> 등)는 내부 텍스트만 재귀적으로 추출
                parts.append(self._get_text_with_includes(child, namespace, call_stack, depth + 1))
            
            if child.tail:
                parts.append(child.tail)
        
        return " ".join(filter(None, parts))
```

**답변 B (대안)**: 이 접근법은 복잡한 동적 SQL 조합을 생성하는 대신, 모든 가능한 텍스트를 합친 후 강력한 정규식 기반의 `SqlJoinAnalyzer`로 분석하여 **최소한의 복잡도로 목표를 달성**하는 실용적인 대안입니다.

### **2.3. `main.py` 및 `xml_loading.py` 통합**

**User Rules 반영**:
- `main.py`에서 분석 시작 전 캐시를 명시적으로 초기화합니다.
- `xml_loading.py`에서 `XmlParser`를 호출하여 분석을 수행합니다.

```python
# D:\Analyzer\CreateMetaDb\main.py 수정

# ... imports ...
from util.cache_utils import get_sql_fragment_cache
from util.config_utils import ConfigUtils
from util.path_utils import PathUtils

def main():
    # ... 기존 로직 (arg parsing, 로거 설정 등) ...
    
    # 1. 설정 파일 로드
    path_utils = PathUtils()
    target_config_path = path_utils.get_config_path('target_source_config.yaml')
    target_config = ConfigUtils().load_yaml_config(target_config_path)

    # 2. SQL 조각 캐시 초기화 (프로세스 당 1회)
    info("SQL 조각 캐시를 초기화합니다...")
    sql_cache = get_sql_fragment_cache()
    sql_cache.load_all_fragments(project_name, target_config)
    
    # 3. 파일 로딩 및 분석 단계 실행
    # xml_loading.py의 함수가 내부적으로 XmlParser와 EnhancedMybatisParser를 사용
    # ...
```

---

## 3. Java AST 분석 (Phase 1-B) - 단순화된 접근법

**User Rules 반영**:
- **목표 집중**: 복잡한 AST 변수 추적 대신, **단순 정규식**으로 SQL 패턴을 가진 문자열 리터럴을 찾는 방식을 채택하여 구현 복잡도를 낮추고 목적을 달성합니다. (질의 4-2-1 반영)
- **안전성**: 정규식 방식은 기존 Java 파서 로직에 영향을 주지 않고 독립적으로 수행될 수 있습니다.

```python
# D:\Analyzer\CreateMetaDb\java_loading.py 내부에 추가될 함수 예시

import re

def extract_sql_from_java_simple(java_content: str) -> List[str]:
    """ Java 코드에서 SQL 패턴을 가진 문자열 리터럴을 추출 (단순 정규식) """
    # SELECT, INSERT, UPDATE, DELETE, MERGE 키워드로 시작하는 문자열 리터럴 탐색
    # 여러 줄에 걸친 문자열("...") + "..." 패턴도 일부 감지
    pattern = re.compile(
        r'"\s*(SELECT|INSERT|UPDATE|DELETE|MERGE)\s+[^"]*?"'
        r'(\s*\+\s*"[^"]*?")*',
        re.IGNORECASE | re.DOTALL
    )
    
    found_sqls = []
    matches = pattern.finditer(java_content)
    for match in matches:
        # 여러 줄로 나뉜 SQL 조각들을 합치고 정리
        sql_literal = match.group(0)
        clean_sql = sql_literal.replace('"', '').replace('+', '').strip()
        found_sqls.append(clean_sql)
        
    return found_sqls
```

**답변 4-2-1 (Java 파싱 단순화)**: 이 방식은 `javalang` 같은 외부 라이브러리 의존성을 없애고, 오탐(false positive)의 위험은 있지만 빠르고 간단하게 대부분의 명시적인 SQL을 추출할 수 있어 **목표 달성에 더 효율적**입니다.

---

## 4. Exception 처리 및 단계별 계획 재확인

- **Exception 처리**:
    - **예상 가능한 오류 (XML 파싱 오류, 순환 참조)**: `warning` 로그 후 해당 파일/부분만 건너뛰고 계속 진행합니다. **프로세스를 중단시키지 않습니다.**
    - **예상치 못한 시스템 오류 (설정 파일 누락, DB 연결 불가 등)**: `handle_error()`를 호출하여 로그를 남기고 **프로세스를 즉시 종료**합니다.
    - **조합 폭발**: `warning` 후 대표 경로 분석으로 Fallback 하므로 `handle_error` 대상이 아닙니다.

- **단계별 계획**: 제안하신 **Phase 1-A, 1-B, 2**의 순서는 매우 합리적입니다. 이 문서에 기술된 구체적인 구현 방안은 **Phase 1-A**를 완벽히 커버하며, Phase 1-B의 Java 분석에 대한 단순화된 접근법도 제시했습니다.

---

**최종 결론**: 이 문서는 User Rules를 모두 준수하며, 안정성과 목표 달성에 초점을 맞춘 구체적인 코드 레벨 구현 가이드입니다. 이 계획에 따라 개발을 진행하는 것을 최종 제안합니다.
