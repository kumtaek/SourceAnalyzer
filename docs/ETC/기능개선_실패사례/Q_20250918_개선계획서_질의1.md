# 개선계획서_Gemini.md 개발 구현 관련 질의서

## 문서 정보
- **작성일**: 2025년 9월 18일
- **질의자**: AI Assistant (개발자 관점)
- **대상 문서**: `docs/기능개선/개선계획서_Gemini.md`
- **질의 목적**: 개발 구현 전 기술적 세부사항 및 실현 가능성 검토

---

## 🎯 핵심 질의사항

### 1. **MyBatis 동적 SQL 분석 - 성능 및 복잡도 관련**

#### 1-1. 조합 폭발 문제
```xml
<select id="complexQuery">
    SELECT * FROM users u
    <if test="includeOrders">LEFT JOIN orders o ON u.id = o.user_id</if>
    <if test="includeProducts">LEFT JOIN products p ON o.product_id = p.id</if>
    <if test="includeCategories">LEFT JOIN categories c ON p.category_id = c.id</if>
    <if test="includeReviews">LEFT JOIN reviews r ON p.id = r.product_id</if>
    <!-- 더 많은 조건문들... -->
</select>
```

**질의**: `<if>` 태그가 10개 이상 중첩된 경우 2^10 = 1024개의 SQL 조합이 생성됩니다. 
- **메모리 사용량**: 1000개 이상의 SQL 문자열을 메모리에 동시 보관하는 것이 현실적인가?
- **처리 시간**: 각각을 SQL 파서로 분석하는 시간이 실용적 범위 내인가?
- **제한 방안**: 조합 수 제한 (예: 최대 100개)이나 우선순위 기반 선별 방식을 고려해야 하는가?

#### 1-2. 중첩 구조 처리
```xml
<if test="advancedSearch">
    <choose>
        <when test="userType == 'PREMIUM'">
            <if test="includeHistory">LEFT JOIN user_history h ON u.id = h.user_id</if>
        </when>
        <otherwise>
            <if test="basicOnly">WHERE u.status = 'ACTIVE'</if>
        </otherwise>
    </choose>
</if>
```

**질의**: `<if>` + `<choose>` + `<when>` 중첩 구조에서
- **재귀 깊이**: 최대 몇 단계까지 재귀를 허용할 것인가?
- **논리 조합**: `<choose>`의 상호배타적 특성과 `<if>`의 독립적 특성을 어떻게 구분 처리할 것인가?
- **에러 처리**: 무한 재귀나 메모리 초과 시 어떻게 graceful degradation할 것인가?

### 2. **MyBatis `<include>` 태그 - 의존성 추적 관련**

#### 2-1. 순환 참조 문제
```xml
<!-- A.xml -->
<sql id="baseQuery">SELECT * FROM users <include refid="commonJoins"/></sql>

<!-- B.xml -->  
<sql id="commonJoins">LEFT JOIN orders o ON u.id = o.user_id <include refid="baseQuery"/></sql>
```

**질의**: 
- **순환 참조 탐지**: 어떤 알고리즘으로 순환 참조를 탐지할 것인가? (DFS, 방문 노드 추적?)
- **에러 처리**: 순환 참조 발견 시 전체 분석을 중단할 것인가, 해당 부분만 스킵할 것인가?
- **성능**: 대규모 프로젝트(XML 파일 100개+)에서 의존성 그래프 구축 시간이 허용 범위 내인가?

#### 2-2. 네임스페이스 충돌
```xml
<!-- UserMapper.xml namespace="com.example.user" -->
<sql id="commonQuery">SELECT * FROM users</sql>

<!-- AdminMapper.xml namespace="com.example.admin" -->
<sql id="commonQuery">SELECT * FROM admins</sql>
```

**질의**:
- **ID 충돌**: 같은 `id`를 가진 `<sql>` 조각이 다른 네임스페이스에 존재할 때 어떻게 해결할 것인가?
- **참조 해석**: `<include refid="commonQuery"/>`가 어느 네임스페이스의 것을 참조하는지 어떻게 결정할 것인가?
- **캐시 키**: SqlFragmentCache에서 네임스페이스를 포함한 고유 키 생성 방식이 충분한가?

### 3. **Java AST 분석 - 라이브러리 및 정확도 관련**

#### 3-1. javalang 라이브러리 한계
```java
// 복잡한 케이스들
String query = buildBaseQuery();  // 메서드 호출 결과
query += condition != null ? " WHERE " + condition : "";  // 삼항 연산자
query = query.replace("{table}", tableName);  // 문자열 치환
```

**질의**:
- **라이브러리 선택**: `javalang`이 최적인가? `tree-sitter-java`나 다른 대안은?
- **정확도**: 메서드 호출, 삼항 연산자, 문자열 메서드 체이닝 등을 어디까지 추적할 것인가?
- **성능**: 대용량 Java 파일(10MB+) AST 파싱 시간이 실용적인가?

#### 3-2. 스코프 및 타입 추론
```java
public void buildQuery(String tableName) {
    String query = "SELECT * FROM ";
    if (tableName != null) {
        query = query + tableName;  // 변수 스코프 내에서만 유효
    }
    // 다른 메서드로 query 전달...
}
```

**질의**:
- **변수 스코프**: 메서드 내 지역변수 스코프를 벗어나는 추적은 어떻게 처리할 것인가?
- **타입 추론**: `String` 외에 `StringBuilder`, `StringBuffer` 등의 타입도 추적할 것인가?
- **한계 설정**: 어느 수준에서 "추적 불가"로 판단하고 포기할 것인가?

### 4. **통합 아키텍처 - 기존 시스템과의 연동**

#### 4-1. 기존 파서와의 충돌
**질의**:
- **호환성**: 현재 `xml_parser.py`의 `MybatisParser` 클래스를 완전히 교체할 것인가, 확장할 것인가?
- **설정 연동**: 기존 `config/parser/*.yaml` 설정들과 새로운 동적 분석 로직이 어떻게 연동될 것인가?
- **에러 처리**: 기존 SAX Fallback 메커니즘과 새로운 동적 분석이 실패했을 때의 처리 방안은?

#### 4-2. 성능 영향 평가
**질의**:
- **처리 시간**: 현재 sampleSrc 분석 시간(약 X분)이 새로운 기능으로 얼마나 증가할 것으로 예상하는가?
- **메모리 사용량**: SqlFragmentCache, 동적 SQL 조합 생성 등으로 메모리 사용량이 얼마나 증가하는가?
- **확장성**: 10배 큰 프로젝트에서도 실용적으로 동작할 것인가?

### 5. **구현 우선순위 및 단계별 검증**

#### 5-1. 최소 기능 구현(MVP)
**질의**:
- **1단계 범위**: Phase 1에서 구현할 최소 기능 범위는 정확히 무엇인가?
  - `<if>` 태그만? `<choose>`도 포함?
  - `<include>` 태그는 같은 파일 내에서만? 크로스 파일도?
  - Java `+` 연산자는 어떤 패턴까지?

#### 5-2. 검증 방법
**질의**:
- **정확성 측정**: 개선 전후 정확도를 어떻게 정량적으로 측정할 것인가?
- **테스트 케이스**: 각 기능별 테스트 케이스는 어떻게 구성할 것인가?
- **성능 벤치마크**: 성능 저하 허용 범위는? (예: 현재 대비 2배 이내)

---

## 🔧 기술적 제안사항

### 1. **점진적 구현 방안**
복잡도를 고려하여 다음과 같은 단계별 접근을 제안합니다:

**1단계**: 단순 `<if>` 태그 (조건 2개 이하)
**2단계**: 같은 파일 내 `<include>` 태그  
**3단계**: Java 단순 `+` 연산자 (3회 이하 결합)
**4단계**: 복잡한 중첩 구조 및 크로스 파일 참조

### 2. **성능 최적화 방안**
- **조합 수 제한**: 최대 50개 SQL 조합까지만 생성
- **캐싱**: 동일한 동적 태그 구조는 캐싱하여 재사용
- **병렬 처리**: 독립적인 SQL 분석은 멀티스레딩 활용

### 3. **에러 처리 전략**
- **Graceful Degradation**: 복잡한 케이스 실패 시 기존 방식으로 fallback
- **부분 성공**: 일부 경로 분석 실패해도 성공한 부분은 결과에 포함
- **상세 로깅**: 실패 원인을 상세히 로깅하여 점진적 개선 지원

---

**질의 요약**: 위 질의사항들에 대한 구체적인 답변과 기술적 방향성을 제시해 주시면, 보다 현실적이고 구현 가능한 개발 계획을 수립할 수 있을 것 같습니다.
