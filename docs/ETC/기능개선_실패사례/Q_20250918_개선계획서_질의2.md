# 개선계획서 구체적 구현 로직 질의서 2

## 문서 정보
- **작성일**: 2025년 9월 18일
- **질의자**: AI Assistant (개발자 관점)
- **대상 문서**: `docs/기능개선/A_20250918_개선계획서_답변1.md`
- **질의 목적**: 답변을 바탕으로 실제 구현 가능한 구체적 로직 설계

---

## 🎯 구체적 구현 로직 질의

### 1. **MyBatis 동적 SQL - 구체적 알고리즘 설계**

#### 1-1. 조합 생성 알고리즘 상세 구현
답변에서 "최대 32개 또는 64개 조합 제한"을 제안했는데, 구체적인 구현 로직이 필요합니다.

```python
# 예시 XML
<select id="testQuery">
    SELECT * FROM users u
    <if test="includeOrders">LEFT JOIN orders o ON u.id = o.user_id</if>
    <if test="includeProducts">LEFT JOIN products p ON o.product_id = p.id</if>
    <if test="includeCategories">LEFT JOIN categories c ON p.category_id = c.id</if>
    WHERE u.status = 'ACTIVE'
</select>
```

**질의 1-1-1**: **조합 생성 순서와 우선순위**
- 3개 `<if>` 태그 → 8개 조합 가능
- 어떤 순서로 조합을 생성할 것인가? (BFS? DFS?)
- 32개 제한 초과 시 어떤 조합을 우선 선택할 것인가?
  - 모든 `<if>` true인 "최대 경로" 우선?
  - 랜덤 선택? 태그 순서 기반?

**질의 1-1-2**: **데이터 구조 설계**
```python
class SqlPath:
    def __init__(self):
        self.sql_fragments = []     # SQL 조각들
        self.active_conditions = [] # 활성화된 조건들
        self.tables = set()         # 이 경로에서 발견된 테이블들
        
# 이런 구조가 적절한가? 다른 제안이 있는가?
```

#### 1-2. 중첩 구조 처리 - 상태 관리 로직
답변에서 "상태를 가진 재귀" 방식을 언급했는데, 구체적 구현이 필요합니다.

```xml
<if test="advancedSearch">
    <choose>
        <when test="userType == 'PREMIUM'">
            <if test="includeHistory">LEFT JOIN user_history h ON u.id = h.user_id</if>
        </when>
        <otherwise>
            WHERE u.status = 'ACTIVE'
        </otherwise>
    </choose>
</if>
```

**질의 1-2-1**: **재귀 상태 관리**
```python
def _process_dynamic_node(self, node, current_paths, depth=0):
    # current_paths: List[SqlPath] - 현재까지의 경로들
    # 어떻게 상태를 관리할 것인가?
    
    if node.tag == 'if':
        # 경로 분기: true/false 두 갈래
        # current_paths를 어떻게 복제하고 분기할 것인가?
        pass
    elif node.tag == 'choose':
        # 상호배타적 분기: when/otherwise 중 하나만
        # 어떻게 구현할 것인가?
        pass
```

**질의 1-2-2**: **메모리 최적화**
- 경로 복제 시 깊은 복사(deep copy) vs 얕은 복사(shallow copy)?
- 중간 결과를 언제 메모리에서 해제할 것인가?

### 2. **SqlFragmentCache 구체적 구현**

#### 2-1. 캐시 구조와 생명주기
```python
class SqlFragmentCache:
    def __init__(self):
        self.fragments = {}          # Dict[str, str]
        self.dependency_graph = {}   # Dict[str, List[str]] - 의존성 그래프
        self.initialized = False
```

**질의 2-1-1**: **캐시 데이터 구조**
- `fragments`에 저장할 값: XML 문자열? 파싱된 Element? SQL 텍스트?
- 의존성 그래프는 정말 필요한가? 메모리 오버헤드 vs 성능 이익?

**질의 2-1-2**: **캐시 무효화 전략**
```python
# 언제 캐시를 새로 로드해야 하는가?
def should_reload_cache(self, project_path: str) -> bool:
    # XML 파일이 변경되었는지 어떻게 감지할 것인가?
    # 파일 수정 시간? 해시값? 
    pass
```

#### 2-2. 순환 참조 탐지 구체적 구현
```python
def _resolve_includes(self, node: ET.Element, refid_stack: Set[str], depth=0) -> str:
    # refid_stack으로 순환 참조 탐지
    # 하지만 구체적 구현이 필요
```

**질의 2-2-1**: **탐지 시점과 처리**
- 순환 참조를 언제 탐지하는가? 캐시 로드 시? 사용 시?
- 순환 참조 발견 시 구체적 처리 로직은?
  ```python
  if refid in refid_stack:
      # 1) 경고 로그만 남기고 빈 문자열 반환?
      # 2) 순환 고리를 끊고 일부만 처리?
      # 3) 전체 include 해석 포기?
      pass
  ```

### 3. **Java AST 분석 - 구체적 파싱 로직**

#### 3-1. 변수 추적 구체적 구현
답변에서 "단순하고 선형적인 패턴만"이라고 했는데, 경계가 모호합니다.

```java
// Case 1: 이것은 지원하는가?
String sql = "SELECT * FROM users";
sql += " WHERE status = 'ACTIVE'";
sql = sql + " ORDER BY created_date";

// Case 2: 이것은 어떤가?
String sql = "SELECT * FROM users";
String condition = " WHERE status = 'ACTIVE'";
sql = sql + condition;  // 변수 참조

// Case 3: 이것은?
String sql = "SELECT * FROM " + tableName;  // 변수 + 리터럴
```

**질의 3-1-1**: **지원 범위 명확화**
- Case 1: ✅ 지원 (리터럴만 사용)
- Case 2: ❌ 불지원 (변수 참조)  
- Case 3: ❌ 불지원 (변수 + 리터럴)
- 이 기준이 맞는가?

**질의 3-1-2**: **AST 노드 처리 로직**
```python
def analyze_method_body_for_sql(self, method_node) -> List[str]:
    tracked_vars = {}  # Dict[str, str]
    
    for path, node in method_node.filter(javalang.tree.Statement):
        if isinstance(node, javalang.tree.LocalVariableDeclaration):
            # 변수 선언 처리
            # 구체적으로 어떤 조건을 체크할 것인가?
            pass
        elif isinstance(node, javalang.tree.ExpressionStatement):
            # 할당 표현식 처리  
            # += 연산자와 = var + literal 구분은?
            pass
```

#### 3-2. SQL 패턴 인식 로직
```python
def _is_likely_sql(self, text: str) -> bool:
    text_upper = text.upper()
    return any(keyword in text_upper for keyword in ['SELECT', 'INSERT', 'UPDATE', 'DELETE'])
```

**질의 3-2-1**: **인식 정확도 개선**
- 현재 로직은 너무 단순해서 오탐이 많을 것 같습니다.
- 다음 중 어떤 방식이 좋을까요?
  ```python
  # 방식 1: 키워드 조합 체크
  def _is_likely_sql_v1(self, text: str) -> bool:
      text_upper = text.upper()
      has_select = 'SELECT' in text_upper and 'FROM' in text_upper
      has_insert = 'INSERT' in text_upper and 'INTO' in text_upper
      # ...
  
  # 방식 2: 정규식 패턴
  def _is_likely_sql_v2(self, text: str) -> bool:
      sql_patterns = [
          r'SELECT\s+.*\s+FROM\s+\w+',
          r'INSERT\s+INTO\s+\w+',
          # ...
      ]
  
  # 방식 3: 실제 SQL 파서로 검증
  def _is_likely_sql_v3(self, text: str) -> bool:
      try:
          # 실제 SQL 파서로 파싱 시도
          return True
      except:
          return False
  ```

### 4. **통합 및 에러 처리 - 구체적 플로우**

#### 4-1. 기존 시스템 통합 지점
현재 `xml_parser.py`의 어느 지점에 새로운 로직을 삽입할 것인가?

```python
# 현재 구조 (추정)
class MybatisParser:
    def parse_sql_mapper(self, xml_root: ET.Element) -> List[Dict[str, str]]:
        # 여기에 새로운 동적 분석 로직을 삽입?
        
    def _process_node(self, node: ET.Element, context: Dict[str, str]) -> str:
        # 아니면 여기에?
```

**질의 4-1-1**: **통합 지점 선택**
- 어느 메서드를 수정/확장할 것인가?
- 기존 로직과 새 로직의 실행 순서는?
- 기존 결과와 새 결과를 어떻게 병합할 것인가?

#### 4-2. Fallback 메커니즘 구체화
```python
def enhanced_parse_sql_node(self, node: ET.Element) -> Dict[str, Any]:
    try:
        # 새로운 동적 분석 시도
        result = self._dynamic_sql_analysis(node)
        if result.get('success'):
            return result
    except Exception as e:
        # Fallback 로직
        logger.warning(f"Dynamic analysis failed: {e}")
        # 기존 방식으로 처리?
        return self._legacy_parse_sql_node(node)
```

**질의 4-2-1**: **실패 판단 기준**
- 어떤 상황을 "실패"로 간주할 것인가?
- Exception 발생? 빈 결과? 시간 초과?

**질의 4-2-2**: **결과 병합 전략**
- 새 방식과 기존 방식 결과가 다를 때 어떻게 처리?
- Union? Intersection? 새 방식 우선?

### 5. **성능 측정 및 검증 구체화**

#### 5-1. 벤치마크 측정 방법
**질의 5-1-1**: **측정 지표 구체화**
```python
class PerformanceBenchmark:
    def measure_parsing_performance(self):
        # 무엇을 측정할 것인가?
        metrics = {
            'total_time': 0,           # 전체 소요 시간
            'memory_usage': 0,         # 메모리 사용량
            'sql_components_found': 0, # 발견된 SQL 컴포넌트 수
            'tables_found': 0,         # 발견된 테이블 수
            'join_relationships': 0,   # 발견된 조인 관계 수
            # 다른 지표들?
        }
```

#### 5-2. 단위 테스트 설계
**질의 5-2-1**: **테스트 케이스 구체화**
```
test_cases/
├── mybatis_dynamic/
│   ├── simple_if.xml          # 단일 <if> 태그
│   ├── nested_if_choose.xml   # 중첩 구조
│   ├── circular_include.xml   # 순환 참조
│   └── complex_combination.xml # 복합 케이스
├── java_dynamic/
│   ├── simple_concat.java     # 단순 + 연산자
│   ├── complex_concat.java    # 복잡한 패턴
│   └── edge_cases.java        # 경계 케이스
└── integration/
    └── full_project/          # 통합 테스트용 미니 프로젝트
```

각 테스트 케이스별로 **예상 결과(Expected Output)**를 어떻게 정의할 것인가?

---

## 🔧 구현 우선순위 재확인

답변을 바탕으로 다음 구현 순서가 적절한지 확인하고 싶습니다:

### Phase 1-A: 기반 구조 (1주)
1. `SqlFragmentCache` 클래스 구현 (순환 참조 탐지 포함)
2. 단순 `<if>` 태그 처리 (중첩 없음, 최대 3개)
3. 기본 단위 테스트 프레임워크

### Phase 1-B: 기능 확장 (1주)  
4. 같은 파일 내 `<include>` 태그 지원
5. Java 단순 `+` 연산자 패턴 (2-3개 리터럴)
6. 통합 테스트 및 성능 측정

### Phase 2: 고도화 (2-3주)
7. 중첩 구조 (`<if>` + `<choose>`)
8. 크로스 파일 `<include>` 지원  
9. Java 복잡 패턴 확장

---

**최종 질의**: 위 모든 구체적 구현 사항들에 대해 명확한 답변을 받은 후, 실제 코딩을 시작할 수 있을 것 같습니다. 특히 **데이터 구조 설계**와 **알고리즘 플로우**에 대한 구체적인 가이드라인이 필요합니다.
